// semaphore:- it's called manage limited resousce 
//  it's have some inbuild method key , put,get, try_put,try_get
//it's synchromize multiple thread
// it's use when we have multiple parallel thread try access same resouce at a time 
// If you have 1 key ‚Üí only 1 person (thread) can enter
// If you have 2 keys ‚Üí 2 threads can enter at the same time

Below is a **real, practical PCIe + UVM project example** based on how semaphores are **actually used in industry PCIe IP verification**, not a textbook case.

You already work on PCIe verification, so I‚Äôll keep this **very realistic and simple**, exactly like what happens in Gen3/Gen4 environments.

---

# üöÄ Real PCIe / UVM Semaphore Example

## **Multiple PCIe Masters ‚Üí One Shared Resource**

---

## üî¥ Problem (Real Project Scenario)

In a PCIe environment you often have:

* Multiple **initiators (masters)**:

  * DMA engine
  * CPU config access
  * Error injection sequence
* One **shared resource**:

  * Configuration Space
  * Register Model (RAL)
  * Shared Memory / BAR
  * Scoreboard / Predictor

### ‚ùå Without semaphore

Two sequences may:

* Write same register simultaneously
* Corrupt expected data
* Cause random failures (non-reproducible bugs)

---

## üü¢ Solution

Use **semaphore** to allow **only one PCIe transaction at a time** to access that resource.

---

## üß† Example 1: Protecting PCIe Configuration Space Access

### Use case:

* `cfg_read_seq`
* `cfg_write_seq`

Both access **same config registers**

---

### üîπ Semaphore declaration (Environment)

```systemverilog
class pcie_env extends uvm_env;

  semaphore cfg_sem;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    cfg_sem = new(1); // Only ONE config access at a time
  endfunction

endclass
```

---

### üîπ Base PCIe Config Sequence

```systemverilog
class pcie_cfg_base_seq extends uvm_sequence;

  `uvm_object_utils(pcie_cfg_base_seq)

  semaphore cfg_sem;

  function new(string name="pcie_cfg_base_seq");
    super.new(name);
  endfunction

  virtual task pre_body();
    // Take semaphore before config access
    cfg_sem.get(1);
    `uvm_info(get_type_name(),
              "CFG semaphore acquired", UVM_MEDIUM)
  endtask

  virtual task post_body();
    // Release semaphore after access
    cfg_sem.put(1);
    `uvm_info(get_type_name(),
              "CFG semaphore released", UVM_MEDIUM)
  endtask

endclass
```

---

### üîπ Config Write Sequence

```systemverilog
class pcie_cfg_wr_seq extends pcie_cfg_base_seq;

  `uvm_object_utils(pcie_cfg_wr_seq)

  virtual task body();
    `uvm_info(get_type_name(),
              "Performing PCIe CFG WRITE", UVM_MEDIUM)

    // Example: write Command Register
    // addr = 0x04
    // data = 32'h0000_0007
  endtask

endclass
```

---

### üîπ Config Read Sequence

```systemverilog
class pcie_cfg_rd_seq extends pcie_cfg_base_seq;

  `uvm_object_utils(pcie_cfg_rd_seq)

  virtual task body();
    `uvm_info(get_type_name(),
              "Performing PCIe CFG READ", UVM_MEDIUM)
  endtask

endclass
```

---

### üîπ Connecting semaphore from ENV to SEQ

```systemverilog
pcie_cfg_wr_seq wr_seq;
pcie_cfg_rd_seq rd_seq;

initial begin
  wr_seq = pcie_cfg_wr_seq::type_id::create("wr_seq");
  rd_seq = pcie_cfg_rd_seq::type_id::create("rd_seq");

  wr_seq.cfg_sem = env.cfg_sem;
  rd_seq.cfg_sem = env.cfg_sem;

  fork
    wr_seq.start(pcie_sequencer);
    rd_seq.start(pcie_sequencer);
  join
end
```

---

## üß™ What happens in simulation?

```
CFG semaphore acquired  --> WR sequence runs
CFG semaphore released
CFG semaphore acquired  --> RD sequence runs
CFG semaphore released
```

‚úÖ No overlap
‚úÖ No race
‚úÖ Deterministic behavior

---

## üî• Example 2: Scoreboard Protection (Very Common)

### Use case:

* RX TLP monitor
* TX TLP monitor
* Both update same scoreboard

---

```systemverilog
class pcie_scoreboard extends uvm_component;

  semaphore sb_sem;

  function new(string name, uvm_component parent);
    super.new(name, parent);
    sb_sem = new(1);
  endfunction

  function void write_rx_tlp(pcie_tlp tlp);
    sb_sem.get(1);
    // update expected queue
    sb_sem.put(1);
  endfunction

  function void write_tx_tlp(pcie_tlp tlp);
    sb_sem.get(1);
    // compare actual vs expected
    sb_sem.put(1);
  endfunction

endclass
```

---

## üß† Example 3: PCIe Multiple DMA Channels ‚Üí Shared Memory

| DMA Channel | Thread |
| ----------- | ------ |
| DMA0        | seq0   |
| DMA1        | seq1   |
| DMA2        | seq2   |

All write to **same BAR memory**

üëâ semaphore size = number of allowed parallel accesses

* `new(1)` ‚Üí strict ordering
* `new(2)` ‚Üí allow two DMAs at once

---

## üîç Why semaphore is preferred in PCIe verification

* Deterministic regression
* No random failures
* Clean scoreboard updates
* Proper ordering of:

  * Posted / Non-Posted
  * Config vs Memory access
  * Error injection vs normal traffic

---

## üí° Interview-Ready Summary

> **In PCIe UVM environments, semaphores are commonly used to protect shared resources such as configuration space, register models, scoreboards, and shared memory when multiple sequences or monitors run in parallel.**

---

If you want next, I can explain:

* `try_get()` usage for **timeout-based PCIe access**
* Semaphore vs **UVM sequencer arbitration**
* Real **PCIe ordering + semaphore** example
* Common **mistakes** with semaphores in UVM

Just tell me üëç
