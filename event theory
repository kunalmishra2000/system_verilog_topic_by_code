// Event:
// Used to synchronize processes (one process waits, another triggers)
// It does NOT manage resources (no counting like semaphore)
// It has inbuilt mechanisms: wait(), @event, ->event, triggered
// Multiple threads can wait on the same event
// When the event is triggered, all waiting threads wake up
// | Operation            | Meaning                       |
// | -------------------- | ----------------------------- |
// | `event e;`           | Declare event                 |
// | `-> e;`              | Trigger event                 |
// | `@e;`                | Wait for event                |
// | `wait(e.triggered);` | Wait until event is triggered |
// | `e.triggered`        | Check if already triggered    |


Your idea is **right**, but the wording is a bit confusing.
Let me **correct it**, then explain with a **clear PCIe / UVM real-project example**, just like before.

---

## âœ… Corrected & clean version of your comments (event)

```systemverilog
// Event:
// Used to synchronize processes (one process waits, another triggers)
// It does NOT manage resources (no counting like semaphore)
// It has inbuilt mechanisms: wait(), @event, ->event, triggered
// Multiple threads can wait on the same event
// When the event is triggered, all waiting threads wake up
```

---

## ğŸ”¹ What an event actually does (very simple)

ğŸ‘‰ **Event is a signal, not a lock**

* One thread says: **â€œI am doneâ€**
* Other threads say: **â€œI will wait until you are doneâ€**

âš ï¸ Event does **not**:

* Protect shared data
* Limit access
* Count resources

---

## ğŸ”‘ Event in SystemVerilog â€“ Key operations

| Operation            | Meaning                       |
| -------------------- | ----------------------------- |
| `event e;`           | Declare event                 |
| `-> e;`              | Trigger event                 |
| `@e;`                | Wait for event                |
| `wait(e.triggered);` | Wait until event is triggered |
| `e.triggered`        | Check if already triggered    |

---

# ğŸš€ Real PCIe / UVM Project Example (Event)

## **Wait for PCIe Link Training Completion**

### ğŸ”´ Real scenario

In PCIe verification:

* Link training (LTSSM) takes time
* No TLP should be sent **before link is UP**
* Multiple sequences must wait

ğŸ‘‰ Perfect use case for **event**

---

## ğŸ”¹ Event declaration (ENV)

```systemverilog
class pcie_env extends uvm_env;

  event link_up_ev;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    link_up_ev = new();
  endfunction

endclass
```

---

## ğŸ”¹ LTSSM Monitor (Triggers event)

```systemverilog
class pcie_ltssm_mon extends uvm_component;

  event link_up_ev;

  virtual task run_phase(uvm_phase phase);
    // Wait until DUT reaches L0
    wait (dut.ltssm_state == L0);

    `uvm_info(get_type_name(),
              "PCIe Link UP detected", UVM_MEDIUM)

    -> link_up_ev;  // Trigger event
  endtask

endclass
```

---

## ğŸ”¹ Traffic Sequence (Waits for event)

```systemverilog
class pcie_mem_wr_seq extends uvm_sequence;

  event link_up_ev;

  virtual task pre_body();
    `uvm_info(get_type_name(),
              "Waiting for PCIe link up", UVM_MEDIUM)

    @link_up_ev;   // Wait here

    `uvm_info(get_type_name(),
              "Link is UP, starting traffic", UVM_MEDIUM)
  endtask

  virtual task body();
    // Send Memory Write TLPs
  endtask

endclass
```

---

## ğŸ”¹ Multiple sequences waiting on same event

```systemverilog
fork
  mem_wr_seq.start(seqr);
  mem_rd_seq.start(seqr);
  cfg_seq.start(seqr);
join
```

âœ” All sequences **wait**
âœ” LTSSM monitor triggers **once**
âœ” All sequences wake up together

---

## ğŸ§  Another Real PCIe Example

### **Error Injection after Enumeration**

* Enumeration sequence finishes
* Then error injection must start

```systemverilog
event enum_done_ev;

// Enumeration sequence
-> enum_done_ev;

// Error injection sequence
@enum_done_ev;
```

---

## ğŸ†š Event vs Semaphore (very important)

| Feature          | Event              | Semaphore            |
| ---------------- | ------------------ | -------------------- |
| Synchronization  | âœ…                  | âœ…                    |
| Resource control | âŒ                  | âœ…                    |
| Counting         | âŒ                  | âœ…                    |
| Multiple waiters | âœ…                  | âŒ (limited by count) |
| Use in PCIe      | Link-up, enum done | CFG, RAL, scoreboard |

---

## ğŸ’¡ Interview One-Liner

> **Event is used for synchronization where one process notifies others to proceed, such as waiting for PCIe link up or enumeration completion.**

---

If you want next, I can:

* Show **event vs semaphore bug example**
* Explain `@event` vs `wait(event.triggered)`
* Give **UVM phase + event coordination**
* Combine **event + semaphore** in one PCIe test

Just say ğŸ‘

  Below are **REAL bugs** that actually happen in **PCIe UVM projects** when **event** and **semaphore** are misused.
Iâ€™ll show **wrong code â†’ what goes wrong â†’ correct code**, very clearly.

---

# ğŸš¨ Bug-1: Using **event** to protect a shared resource

### (This is a classic PCIe scoreboard / RAL bug)

---

## âŒ WRONG: Event used like a lock

### Scenario

* RX monitor and TX monitor update **same scoreboard queue**
* Developer uses **event** instead of semaphore

```systemverilog
event sb_ev;

function void write_rx_tlp(pcie_tlp tlp);
  @sb_ev;              // wait
  exp_q.push_back(tlp);
  -> sb_ev;            // trigger
endfunction

function void write_tx_tlp(pcie_tlp tlp);
  @sb_ev;              // wait
  compare(tlp);
  -> sb_ev;            // trigger
endfunction
```

---

## ğŸ’¥ What goes wrong?

* Both threads may wake up **at the same time**
* Event has **no ownership**
* No mutual exclusion
* Queue corruption / random compare failures

â— **Event â‰  mutex**

---

## âœ… CORRECT: Use semaphore for shared resource

```systemverilog
semaphore sb_sem = new(1);

function void write_rx_tlp(pcie_tlp tlp);
  sb_sem.get(1);
  exp_q.push_back(tlp);
  sb_sem.put(1);
endfunction

function void write_tx_tlp(pcie_tlp tlp);
  sb_sem.get(1);
  compare(tlp);
  sb_sem.put(1);
endfunction
```

âœ” Only one thread at a time
âœ” Deterministic scoreboard
âœ” No random failures

---

# ğŸš¨ Bug-2: Using **semaphore** to wait for PCIe link-up

### (Deadlock bug)

---

## âŒ WRONG: Semaphore for notification

```systemverilog
semaphore link_sem = new(0);

// Traffic sequence
task run();
  link_sem.get(1);   // WAIT for link up
  send_tlp();
endtask

// LTSSM monitor
task run();
  if (ltssm_state == L0)
    link_sem.put(1);
endtask
```

---

## ğŸ’¥ What goes wrong?

* If monitor runs **before** sequence
* `put()` happens first
* Semaphore count becomes 1
* Sequence later does `get()` â†’ OK

BUTâ€¦

âš ï¸ If **multiple sequences** do `get(1)`

* Only ONE wakes up
* Others block forever

â— Link-up is **broadcast**, not resource

---

## âœ… CORRECT: Use event for link-up

```systemverilog
event link_up_ev;

// Monitor
-> link_up_ev;

// All sequences
@link_up_ev;
```

âœ” All sequences wake up
âœ” No deadlock
âœ” Correct semantics

---

# ğŸš¨ Bug-3: Missing event trigger (lost event)

---

## âŒ WRONG

```systemverilog
event enum_done_ev;

// Enumeration finishes early
-> enum_done_ev;

// Error injection sequence starts later
@enum_done_ev;   // âŒ waits forever
```

---

## ğŸ’¥ What goes wrong?

* Event triggered **before wait**
* Event does **not remember history**
* Sequence blocks forever

---

## âœ… CORRECT FIX-1: Use `triggered`

```systemverilog
if (!enum_done_ev.triggered)
  @enum_done_ev;
```

---

## âœ… CORRECT FIX-2: Use semaphore or flag

```systemverilog
bit enum_done;

// Enumeration
enum_done = 1;

// Error injection
wait (enum_done);
```

---

# ğŸš¨ Bug-4: Mixing event + shared data (race)

---

## âŒ WRONG

```systemverilog
event data_ready;
int data;

task producer();
  data = 32'hDEAD;
  -> data_ready;
endtask

task consumer();
  @data_ready;
  $display("data=%h", data); // race possible
endtask
```

---

## ğŸ’¥ What goes wrong?

* Multiple consumers read same data
* Data may change before read
* No protection

---

## âœ… CORRECT: Event + Semaphore together

```systemverilog
event data_ready;
semaphore data_sem = new(1);
int data;

task producer();
  data_sem.get(1);
  data = 32'hDEAD;
  data_sem.put(1);
  -> data_ready;
endtask

task consumer();
  @data_ready;
  data_sem.get(1);
  $display("data=%h", data);
  data_sem.put(1);
endtask
```

---

# ğŸ§  Golden Rule (Very Important)

> **Event = â€œWhen can I start?â€**
> **Semaphore = â€œWho is allowed to access?â€**

---

# ğŸ†š Quick Decision Table

| Situation             | Use       |
| --------------------- | --------- |
| PCIe link up          | Event     |
| Enumeration done      | Event     |
| Config space access   | Semaphore |
| Shared scoreboard     | Semaphore |
| Notify many sequences | Event     |
| Protect shared data   | Semaphore |

---

## ğŸ¯ Interview Killer Line

> **Using event instead of semaphore for shared resources causes race conditions, while using semaphore instead of event for notifications can cause deadlocks.**

---

If you want next, I can:

* Show **waveform-level bug**
* Give **PCIe regression failure example**
* Explain **event ordering inside UVM phases**
* Show **mailbox vs event vs semaphore**

Just say ğŸ‘
Below is **exactly what you asked for** â€” **waveform-level bug explanation** + **real PCIe regression failure example**, explained **step-by-step** the way it shows up in actual projects.

Iâ€™ll keep it **visual (ASCII waveforms)** and **realistic**, not theory.

---

# 1ï¸âƒ£ Waveform-Level Bug

## âŒ Event used instead of Semaphore (Race Condition)

### ğŸ“Œ Scenario (Very common)

* RX Monitor and TX Monitor update **same scoreboard queue**
* Event used to â€œcontrol accessâ€

---

## âŒ Wrong Code (root cause)

```systemverilog
event sb_ev;

task rx_mon();
  @sb_ev;
  exp_q.push_back(rx_tlp);
  -> sb_ev;
endtask

task tx_mon();
  @sb_ev;
  compare(tx_tlp);
  -> sb_ev;
endtask
```

---

## ğŸ” Waveform-Level Timeline

```
Time â†’
---------------------------------------------------------------

sb_ev        ____/Â¯Â¯\__________/Â¯Â¯\__________
                 â†‘              â†‘
               trigger         trigger

RX thread    wait | RUN -----------------------|
                exp_q.push

TX thread    wait | RUN -----------------------|
                compare()

exp_q size       0 â†’ 1 â†’ ??? (corrupted)
```

### â— What happens in waveform?

* Both RX and TX wake **at the SAME time**
* Both execute **inside critical section**
* Queue modified while being read

âš ï¸ **No ownership, no exclusion**

---

## ğŸ’¥ Result

* Compare happens before push completes
* Random mismatches
* Failure depends on **delta cycles**

---

## âœ… Correct Waveform (Semaphore)

```systemverilog
semaphore sb_sem = new(1);
```

```
Time â†’
---------------------------------------------------------------

sb_sem count   1 â†’ 0 â†’ 1 â†’ 0 â†’ 1

RX thread      get | RUN ----------| put
TX thread           wait | RUN ----------| put

exp_q size     0 â†’ 1 â†’ stable
```

âœ” Serialized access
âœ” Deterministic waveform

---

# 2ï¸âƒ£ Waveform-Level Bug

## âŒ Lost Event (Sequence waits forever)

---

### âŒ Wrong Code

```systemverilog
event link_up_ev;

// LTSSM monitor
-> link_up_ev;

// Traffic sequence
@link_up_ev;
```

---

## ğŸ” Waveform

```
Time â†’
--------------------------------------------------

link_up_ev   ____/Â¯Â¯\_________________________
                 â†‘
             triggered early

seq_wait         |-------- WAIT FOREVER -------|
```

### â— Why?

* Event fired **before wait**
* Event does **not latch**
* No memory of past trigger

---

## âœ… Correct Waveform

```systemverilog
if (!link_up_ev.triggered)
  @link_up_ev;
```

```
Time â†’
--------------------------------------------------

link_up_ev   ____/Â¯Â¯\_________________________

seq_wait     check | RUN ---------------------|
```

---

# 3ï¸âƒ£ PCIe Regression Failure Example

## âŒ Random CFG Read Mismatch (Real Project Issue)

---

### ğŸ“Œ Test Name

```
pcie_cfg_parallel_stress
```

### ğŸ“Œ Setup

* CPU config sequence
* Error injection config sequence
* Both run in parallel
* **No semaphore** on config access

---

### âŒ Failure Log (Realistic)

```
UVM_ERROR @ 123456ns [PCIE_SB]
CFG READ MISMATCH
ADDR : 0x04 (Command Register)
EXP  : 0x00000007
ACT  : 0x00000005
```

---

### ğŸ” Root Cause (Waveform)

```
Time â†’
---------------------------------------------------------------

CPU CFG WR     |---- WR 0x04 = 0x7 ----|

ERR CFG WR          |---- WR 0x04 = 0x5 ----|

CFG RD                    |---- RD 0x04 ----|

Expected             0x7
Actual               0x5   âŒ
```

â— Writes overlapped
â— Ordering broken
â— Regression fails randomly

---

### âœ… Fix

```systemverilog
semaphore cfg_sem = new(1);
```

```
CPU WR   |---- WR ----|
ERR WR        |---- WR ----|
CFG RD               |---- RD ----|
```

âœ” Clean ordering
âœ” Stable regression

---

# 4ï¸âƒ£ PCIe Regression Failure Example

## âŒ TLP Sent Before Link-Up

---

### âŒ Failure Log

```
UVM_FATAL [PCIE_PROTOCOL]
TLP transmitted while LTSSM != L0
Current state = POLLING
```

---

### ğŸ” Waveform

```
Time â†’
--------------------------------------------------

LTSSM      POLLING ----> CONFIG ----> L0

TLP            |---- Memory Write ----|   âŒ
```

---

### âŒ Root Cause

* No event synchronization
* Sequence started before link-up

---

### âœ… Fix

```systemverilog
@link_up_ev;
send_tlp();
```

```
LTSSM      POLLING ----> CONFIG ----> L0
link_up_ev                        â†‘
TLP                                     |---- WR ----|
```

âœ” Protocol-correct
âœ” Regression stable

---

# ğŸ§  Final Golden Rule (Waveform View)

```
Event     : broadcast edge (no protection)
Semaphore : exclusive level (protection)
```

---

## ğŸ¯ Interview Mic-Drop Line

> **Event bugs show up as delta-cycle races and lost triggers in waveforms, while semaphore bugs show up as deadlocks or corrupted shared state causing random PCIe regression failures.**

---

If you want next, I can:

* Draw **actual UVM phase vs event waveform**
* Show **mailbox waveform bug**
* Show **Gen4 stress regression failure**
* Convert this into **interview answers + diagrams**

Just say ğŸ‘
