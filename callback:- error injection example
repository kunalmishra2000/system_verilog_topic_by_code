Great set of asks üëç
I‚Äôll go **step-by-step**, starting from your **simple SV callback**, then scaling it to **UVM** and finally a **real PCIe bad-TLP example** (driver-level, project-style).

---

# 1Ô∏è‚É£ **Timing-based Error Injection**

### Goal

Inject error **only at a specific time / cycle / condition**, not always.

### Example: Inject error on 3rd call to `sum()`

```systemverilog
class ch extends packet;
  int count = 0;

  virtual function void call_back();
    count++;

    if (count == 3) begin
      $display("TIMING ERROR: injecting on 3rd transaction");
      a = 0;   // corrupt data
    end
  endfunction
endclass
```

‚úî Simulates:

* PCIe error on **Nth TLP**
* Error after link is stable
* Rare corner-case bugs

---

# 2Ô∏è‚É£ **Random Error Injection**

### Goal

Inject errors **probabilistically**, like real hardware noise.

```systemverilog
class ch extends packet;

  virtual function void call_back();
    if ($urandom_range(0,9) == 0) begin
      $display("RANDOM ERROR injected");
      a = a ^ 32'hFF;   // bit corruption
    end
  endfunction

endclass
```

‚úî Simulates:

* Bit flips
* EMI / signal noise
* Stress testing

---

# 3Ô∏è‚É£ **Enable / Disable Callback via Knob**

### Goal

Turn error injection **ON/OFF without code changes**

### Add knob in base class

```systemverilog
class packet;
  bit enable_err = 0;

  function void sum();
    if (enable_err)
      call_back();
    c = a + b;
    $display("c=%0d", c);
  endfunction

  virtual function void call_back();
  endfunction
endclass
```

### Control from test

```systemverilog
initial begin
  c1 = new();
  c1.enable_err = 1;   // enable error injection
  c1.sum();
end
```

‚úî Real projects use:

* `+ERR_EN=1` plusarg
* config DB
* registers

---

# 4Ô∏è‚É£ **Same Logic Using UVM Callbacks (Industry-Correct)**

---

## üîπ Callback Base Class

```systemverilog
class drv_cb extends uvm_callback;

  virtual task pre_drive(uvm_sequence_item req);
  endtask

endclass
```

---

## üîπ Driver with Callback Hook

```systemverilog
class pcie_driver extends uvm_driver #(pcie_tlp);

  `uvm_component_utils(pcie_driver)
  `uvm_register_cb(pcie_driver, drv_cb)

  task run_phase(uvm_phase phase);
    forever begin
      seq_item_port.get_next_item(req);

      // CALLBACK HOOK
      `uvm_do_callbacks(pcie_driver, drv_cb, pre_drive(req))

      drive_tlp(req);
      seq_item_port.item_done();
    end
  endtask

endclass
```

---

## üîπ Error Injection Callback

```systemverilog
class bad_tlp_cb extends drv_cb;

  virtual task pre_drive(pcie_tlp req);
    $display("Injecting BAD TLP");

    req.lcrc = 32'hDEAD_BEEF;   // corrupt LCRC
  endtask

endclass
```

---

## üîπ Register Callback in Test

```systemverilog
class pcie_err_test extends uvm_test;

  bad_tlp_cb cb;

  task connect_phase(uvm_phase phase);
    cb = new();
    uvm_callbacks#(pcie_driver, drv_cb)::add(env.drv, cb);
  endtask

endclass
```

‚úî This is **exactly how real PCIe projects do it**.

---

# 5Ô∏è‚É£ **PCIe Bad-TLP Examples (REAL PROJECT STYLE)**

### üî¥ Example 1: Bad LCRC

```systemverilog
req.lcrc ^= 32'h1;
```

‚úî Expected:

* Receiver sends **NAK**
* Replay occurs

---

### üî¥ Example 2: Length Violation

```systemverilog
req.length = 1024;  // exceeds MPS
```

‚úî Expected:

* Malformed TLP
* Error logged

---

### üî¥ Example 3: 4KB Boundary Violation

```systemverilog
req.addr = 32'h0000_FFF0;
req.length = 32;    // crosses 4KB boundary
```

‚úî Expected:

* UR / CA completion
* Protocol checker fires

---

### üî¥ Example 4: Invalid Tag

```systemverilog
req.tag = 8'hFF;
```

‚úî Expected:

* Completion timeout
* Error recovery

---

# 6Ô∏è‚É£ **Why Callbacks Are Preferred (Industry Reason)**

| Method          | Problem                 |
| --------------- | ----------------------- |
| Modify driver   | Breaks golden flow      |
| Modify sequence | Limited scope           |
| Force signals   | Unscalable              |
| **Callbacks**   | ‚úÖ Clean, reusable, safe |

---

# 7Ô∏è‚É£ One-Page Mental Model

```
Base Driver
   |
   |---- pre_drive()   <-- callback hook
   |
User Callback
   |
   |---- corrupt fields
```

---

# 8Ô∏è‚É£ Interview-Ready Summary (VERY IMPORTANT)

> Timing-based and random error injection are implemented using callbacks so errors can be injected conditionally, probabilistically, or selectively without modifying base driver code. This is the standard methodology used for PCIe bad-TLP and protocol-violation testing in UVM environments.

---

If you want next:

* **Replay timer + bad LCRC scenario**
* **Link recovery test flow**
* **Callback vs sequence vs monitor injection**
* **How Cadence / Synopsys VIP does this internally**

Just say üëç
